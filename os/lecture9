Something about server? (I think this is referring to distributed systems)
2. non-blocking send and blocking receive
  requires a buffer
3. non blocking send and non blocking receive
  -sender sends out it's message and continues
  -receiver checks for message but keeps going
  -most robust on failure to deliver
  -doesn't guarantee in order delivery


To do this (pass messages) we need:
1. communication medium (includes addressing)
2. some form of synchronization (prevent messages over writing eachother on medium)
3. buffering
4. error handling

Medium: memory
  -addressing:
    1. direct adressing through pid
      -can be be blocking or non blocking
      a) symmetric addressing
        -send(P, msg)
        -recv(Q,&msg)
      b) asymmetric adressing
        -recv(&Q, &msg)
    2. indirect addressing through intermediary (like clients communicating through server)
      -intermediary is a "mailbox"
      -typically the mailbox is a queue
      -multiple senders and multiple receivers can use the same mailbox

On the topic of buffering:
  1. zero capacity (can be used with fully blocking communication)
  2. bounded capacity
    -queue can fill up
    -full queue sender error can occur
  3. "unlimited" capacity queue
    -sender never has to wait

On topic of error handling:
  -eg process dies with message in transit
  -error handling is DIY

In unix for inter process communication we're going to look at
-signals
-pipes
-and something else I missed


Signals:
  -generated by some kind of event
    -pending until received
    -when it's received and acted on it's considered delivered
    -software interrupt - real time & asynchronous
    -sends a msg identified by a signum (int)
      -no payload